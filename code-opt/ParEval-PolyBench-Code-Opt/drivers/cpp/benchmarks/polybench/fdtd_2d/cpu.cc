// Driver for 15_graph_edge_count for Serial, OpenMP, MPI, and MPI+OpenMP
// /* Count the number of edges in the graph defined by the adjacency matrix A.
//    A is an NxN adjacency matrix stored in row-major.
//    Example:
// 
// 	 input: [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [1, 1, 1, 0]]
//    output: 3
// */
// int edgeCount(std::vector<int> const& A, size_t N) {

#include <algorithm>
#include <cmath>
#include <numeric>
#include <random>
#include <vector>

#include "utilities.hpp"
#include "baseline.hpp"
#include "generated-code.hpp"   // code generated by LLM

#include <iostream>
#include <chrono>
#include <omp.h>

struct Context {
    std::vector<std::vector<double>> ex, ey, hz;
    std::vector<double> _fict_;
    int tmax, nx, ny;
};

void reset(Context *ctx, std::mt19937& engine) {
    for (int i = 0; i < ctx->tmax; i++) {
	ctx->_fict_[i] = (double) i;
    }

    for (int i = 0; i < ctx->nx; i++) {
	for (int j = 0; j < ctx->ny; j++) {
	    ctx->ex[i][j] = (i*(j+1)) * 1.0 / ctx->nx;
	    ctx->ey[i][j] = (i*(j+2)) * 1.0 / ctx->ny;
	    ctx->hz[i][j] = (i*(j+3)) * 1.0 / ctx->nx;
	}
    }
}

Context *init() {
    Context *ctx = new Context();

    ctx->tmax = 500;
    ctx->nx = DRIVER_PROBLEM_SIZE;
    ctx->ny = DRIVER_PROBLEM_SIZE / 2;

    ctx->ex.resize(ctx->nx);
    ctx->ey.resize(ctx->nx);
    ctx->hz.resize(ctx->nx);
    ctx->_fict_.resize(ctx->tmax);

    for (int i = 0; i < ctx->nx; i++) {
        ctx->ex[i].resize(ctx->ny);
        ctx->ey[i].resize(ctx->ny);
        ctx->hz[i].resize(ctx->ny);
    }

    // reset(ctx);
    return ctx;
}

Context* copy(Context* ctx) {
    Context* new_ctx = new Context();
    *new_ctx = *ctx;
    return new_ctx;
}

void NO_OPTIMIZE compute(Context *ctx) {
    submission::kernel_fdtd_2d(ctx->tmax, ctx->nx, ctx->ny, ctx->ex, ctx->ey, ctx->hz, ctx->_fict_);
}

void NO_OPTIMIZE best(Context *ctx) {
    correct_kernel_fdtd_2d(ctx->tmax, ctx->nx, ctx->ny, ctx->ex, ctx->ey, ctx->hz, ctx->_fict_);
}

bool validate(Context *ctx, std::mt19937& engine) {
    const size_t TEST_SIZE = DRIVER_PROBLEM_SIZE;

    int tmax = 500;
    int nx = TEST_SIZE;
    int ny = nx / 2;

    std::vector<std::vector<double>> ex;
    std::vector<std::vector<double>> ey;
    std::vector<std::vector<double>> hz;

    std::vector<std::vector<double>> ex_test;
    std::vector<std::vector<double>> ey_test;
    std::vector<std::vector<double>> hz_test;
    std::vector<double> _fict_;

    ex.resize(nx);
    ey.resize(nx);
    hz.resize(nx);
    _fict_.resize(tmax);

    ex_test.resize(nx);
    ey_test.resize(nx);
    hz_test.resize(nx);

    for (int i = 0; i < nx; i++) {
        ex[i].resize(ny);
        ey[i].resize(ny);
        hz[i].resize(ny);

        ex_test[i].resize(ny);
        ey_test[i].resize(ny);
        hz_test[i].resize(ny);
    }

    for (int i = 0; i < tmax; i++) {
	_fict_[i] = (double) i;
    }

    for (int i = 0; i < nx; i++) {
	for (int j = 0; j < ny; j++) {
	    ex[i][j] = (i*(j+1)) * 1.0 / nx;
	    ey[i][j] = (i*(j+2)) * 1.0 / ny;
	    hz[i][j] = (i*(j+3)) * 1.0 / nx;

	    ex_test[i][j] = (i*(j+1)) * 1.0 / nx;
	    ey_test[i][j] = (i*(j+2)) * 1.0 / ny;
	    hz_test[i][j] = (i*(j+3)) * 1.0 / nx;
	}
    }

    // compute correct result
    correct_kernel_fdtd_2d(tmax, nx, ny, ex, ey, hz, _fict_);

    // compute test result
    submission::kernel_fdtd_2d(tmax, nx, ny, ex_test, ey_test, hz_test, _fict_);
    
    bool isCorrect = true;
    for (int i = 0; i < nx; i++) {
	if (!fequal(ex[i], ex_test[i], 1e-4)) {
	    isCorrect = false;
	    break;
	}
	if (!fequal(ey[i], ey_test[i], 1e-4)) {
	    isCorrect = false;
	    break;
	}
	if (!fequal(hz[i], hz_test[i], 1e-4)) {
	    isCorrect = false;
	    break;
	}
    }

    if (!isCorrect) {
	return false;
    }

    return true;
}

void destroy(Context *ctx) {
    delete ctx;
}
