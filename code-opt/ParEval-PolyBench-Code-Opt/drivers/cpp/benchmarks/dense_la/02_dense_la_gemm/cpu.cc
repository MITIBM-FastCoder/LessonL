// Driver for 02_dense_la_gemm for Serial, OpenMP, MPI, and MPI+OpenMP
// /* Multiply the matrix A by the matrix B. Store the results in the matrix C.
//    A is an MxK matrix, B is a KxN matrix, and C is a MxN matrix. The matrices are stored in row-major.
//    Example:
// 
//    input: A=[[1, -1, 2], [0, -2, 1]] B=[[4, 1], [-1, 0], [2, 2]]
//    output: C=[[9, 5], [4, 2]]
// */
// void gemm(std::vector<double> const& A, std::vector<double> const& B, std::vector<double> &C, size_t M, size_t K, size_t N) {

#include <algorithm>
#include <cmath>
#include <numeric>
#include <random>
#include <vector>

#include "utilities.hpp"
#include "baseline.hpp"
#include "generated-code.hpp"   // code generated by LLM

struct Context {
    std::vector<double> A, B, C;
    size_t M, K, N;
};

void reset(Context *ctx, std::mt19937& engine) {
    std::uniform_real_distribution<> dist(-1.0, 1.0);

    auto gen = [&](){ return dist(engine); };

    std::generate(ctx->A.begin(), ctx->A.end(), gen);
    std::generate(ctx->B.begin(), ctx->B.end(), gen);

    // fillRand(ctx->A, -1.0, 1.0, engine);
    // fillRand(ctx->B, -1.0, 1.0, engine);
    std::fill(ctx->C.begin(), ctx->C.end(), 0.0);

    BCAST(ctx->A, DOUBLE);
    BCAST(ctx->B, DOUBLE);
    BCAST(ctx->C, DOUBLE);
}

Context *init() {
    Context *ctx = new Context();

    ctx->M = DRIVER_PROBLEM_SIZE;
    ctx->K = DRIVER_PROBLEM_SIZE / 4;
    ctx->N = DRIVER_PROBLEM_SIZE / 2;

    ctx->A.resize(ctx->M * ctx->K);
    ctx->B.resize(ctx->K * ctx->N);
    ctx->C.resize(ctx->M * ctx->N);

    // reset(ctx);
    return ctx;
}

Context* copy(Context* ctx) {
    Context* new_ctx = new Context();
    *new_ctx = *ctx;
    return new_ctx;
}

void NO_OPTIMIZE compute(Context *ctx) {
    submission::gemm(ctx->A, ctx->B, ctx->C, ctx->M, ctx->K, ctx->N);
}

void NO_OPTIMIZE best(Context *ctx) {
    correctGemm(ctx->A, ctx->B, ctx->C, ctx->M, ctx->K, ctx->N);
}

bool validate(Context *ctx, std::mt19937& engine) {
    const size_t TEST_SIZE = DRIVER_PROBLEM_SIZE;

    std::vector<double> A(TEST_SIZE * TEST_SIZE), B(TEST_SIZE * TEST_SIZE), correct(TEST_SIZE * TEST_SIZE), test(TEST_SIZE * TEST_SIZE);

    int rank;
    GET_RANK(rank);

    std::uniform_real_distribution<> dist(-1.0, 1.0);

    auto gen = [&](){ return dist(engine); };

    std::generate(A.begin(), A.end(), gen);
    std::generate(B.begin(), B.end(), gen);

    // fillRand(A, -1.0, 1.0, engine);
    // fillRand(B, -1.0, 1.0, engine);
    std::fill(correct.begin(), correct.end(), 0.0);
    std::fill(test.begin(), test.end(), 0.0);

    BCAST(A, DOUBLE);
    BCAST(B, DOUBLE);

    // compute correct result
    correctGemm(A, B, correct, TEST_SIZE, TEST_SIZE, TEST_SIZE);

    // compute test result
    submission::gemm(A, B, test, TEST_SIZE, TEST_SIZE, TEST_SIZE);
    SYNC();
        
    bool isCorrect = true;
    if (IS_ROOT(rank) && !fequal(correct, test, 1e-4)) {
        isCorrect = false;
    }
    BCAST_PTR(&isCorrect, 1, CXX_BOOL);
    if (!isCorrect) {
        return false;
    }

    return true;

    /*
    const size_t numTries = MAX_VALIDATION_ATTEMPTS;
    for (int trialIter = 0; trialIter < numTries; trialIter += 1) {
        // set up input
        fillRand(A, -1.0, 1.0);
        fillRand(B, -1.0, 1.0);
        std::fill(correct.begin(), correct.end(), 0.0);
        std::fill(test.begin(), test.end(), 0.0);

        BCAST(A, DOUBLE);
        BCAST(B, DOUBLE);

        // compute correct result
        correctGemm(A, B, correct, TEST_SIZE, TEST_SIZE, TEST_SIZE);

        // compute test result
	submission::gemm(A, B, test, TEST_SIZE, TEST_SIZE, TEST_SIZE);
        SYNC();
        
        bool isCorrect = true;
        if (IS_ROOT(rank) && !fequal(correct, test, 1e-4)) {
            isCorrect = false;
        }
        BCAST_PTR(&isCorrect, 1, CXX_BOOL);
        if (!isCorrect) {
            return false;
        }
    }

    return true;
    */
}

void destroy(Context *ctx) {
    delete ctx;
}
