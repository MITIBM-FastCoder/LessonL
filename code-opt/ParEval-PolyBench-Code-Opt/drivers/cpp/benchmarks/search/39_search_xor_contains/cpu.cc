// Driver for 39_search_xor_contains for Serial, OpenMP, MPI, and MPI+OpenMP
// /* Return true if `val` is only in one of vectors x or y.
//    Return false if it is in both or neither.
//    Examples:
// 
//    input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=7
//    output: true
// 
//    input: x=[1,8,4,3,2], y=[3,4,4,1,1,7], val=1
//    output: false
// */
// bool xorContains(std::vector<int> const& x, std::vector<int> const& y, int val) {

#include <algorithm>
#include <cmath>
#include <numeric>
#include <random>
#include <vector>

#include "utilities.hpp"
#include "baseline.hpp"
#include "generated-code.hpp"   // code generated by LLM

struct Context {
    std::vector<int> x;
    std::vector<int> y;
    int val;
};

void reset(Context *ctx, std::mt19937& engine) {
    std::uniform_int_distribution<> rand_bit_dist(0, 1);
    auto rand_bit = rand_bit_dist(engine);

    std::uniform_int_distribution<> dist(-1e8, 1e8);
    auto gen = [&](){ return dist(engine); };

    std::generate(ctx->x.begin(), ctx->x.end(), gen);
    std::generate(ctx->y.begin(), ctx->y.end(), gen);

    std::cout << "rand bit: " << rand_bit << std::endl;

    if (rand_bit == 0) {
        std::uniform_int_distribution<> idx_dist(0, ctx->x.size() - 1);
	auto rand_idx_x = idx_dist(engine);
	auto rand_idx_y = idx_dist(engine);
	auto rand_value = dist(engine);
	ctx->x[rand_idx_x] = rand_value;
	ctx->y[rand_idx_y] = rand_value;
	ctx->val = rand_value;
    } else {
	ctx->val = dist(engine);
    }

    // fillRand(ctx->x, -10000, 10000);
    // fillRand(ctx->y, -10000, 10000);
    // ctx->val = rand() % 1000;

    BCAST(ctx->x, INT);
    BCAST(ctx->y, INT);
    BCAST_PTR(&ctx->val, 1, INT);
}

Context *init() {
    Context *ctx = new Context();

    ctx->x.resize(DRIVER_PROBLEM_SIZE);
    ctx->y.resize(DRIVER_PROBLEM_SIZE);

    // reset(ctx);
    return ctx;
}

Context* copy(Context* ctx) {
    Context* new_ctx = new Context();
    *new_ctx = *ctx;
    return new_ctx;
}

void NO_OPTIMIZE compute(Context *ctx) {
    bool found = submission::xorContains(ctx->x, ctx->y, ctx->val);
    (void)found;
    asm volatile ("" : "+r"(found));  // Prevents compiler from optimizing var away
}

void NO_OPTIMIZE best(Context *ctx) {
    bool found = correctXorContains(ctx->x, ctx->y, ctx->val);
    (void)found;
    asm volatile ("" : "+r"(found));  // Prevents compiler from optimizing var away
}

bool validate(Context *ctx, std::mt19937& engine) {
    const size_t TEST_SIZE = DRIVER_PROBLEM_SIZE;

    int rank;
    GET_RANK(rank);

    // set up input
    std::vector<int> x(TEST_SIZE);
    std::vector<int> y(TEST_SIZE);

    std::uniform_int_distribution<> dist(-1e8, 1e8);
    auto gen = [&](){ return dist(engine); };

    std::generate(x.begin(), x.end(), gen);
    std::generate(y.begin(), y.end(), gen);

    std::uniform_int_distribution<> idx_dist(0, TEST_SIZE - 1);
    auto rand_idx_x = idx_dist(engine);
    auto rand_idx_y = idx_dist(engine);
    auto rand_value = dist(engine);
    x[rand_idx_x] = rand_value;
    y[rand_idx_y] = rand_value;
    int val = rand_value;

    // fillRand(x, -100, 100);
    // fillRand(y, -100, 100);
    // int val = rand() % 200 - 100;
    BCAST(x, INT);
    BCAST(y, INT);
    BCAST_PTR(&val, 1, INT);

    // compute correct result
    bool correct = correctXorContains(x, y, val);

    // compute test result
    bool test = submission::xorContains(x, y, val);
    SYNC();
        
    bool isCorrect = true;
    if (IS_ROOT(rank) && test != correct) {
        isCorrect = false;
    }
    BCAST_PTR(&isCorrect, 1, CXX_BOOL);
    if (!isCorrect) {
        return false;
    }

    val = dist(engine);
    BCAST_PTR(&val, 1, INT);

    // compute correct result
    correct = correctXorContains(x, y, val);

    // compute test result
    test = submission::xorContains(x, y, val);
    SYNC();
        
    if (IS_ROOT(rank) && test != correct) {
        isCorrect = false;
    }
    BCAST_PTR(&isCorrect, 1, CXX_BOOL);
    if (!isCorrect) {
        return false;
    }

    return true;

    /*
    const size_t numTries = 10;
    for (int i = 0; i < numTries; i += 1) {
        // set up input
        std::vector<int> x(TEST_SIZE);
        std::vector<int> y(TEST_SIZE);
        fillRand(x, -100, 100);
        fillRand(y, -100, 100);
        int val = rand() % 200 - 100;
        if (i == 1) {
            x[rand() % x.size()] = val;
            y[rand() % y.size()] = val;
        }
        BCAST(x, INT);
        BCAST(y, INT);
        BCAST_PTR(&val, 1, INT);

        // compute correct result
        bool correct = correctXorContains(x, y, val);

        // compute test result
        bool test = submission::xorContains(x, y, val);
        SYNC();
        
        bool isCorrect = true;
        if (IS_ROOT(rank) && test != correct) {
            isCorrect = false;
        }
        BCAST_PTR(&isCorrect, 1, CXX_BOOL);
        if (!isCorrect) {
            return false;
        }
    }

    return true;
    */
}

void destroy(Context *ctx) {
    delete ctx;
}
