[
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_atax(int m, int n,\n\t\t std::vector<std::vector<double>>& A,\n\t\t std::vector<double>& x,\n\t\t std::vector<double>& y,\n\t\t std::vector<double>& tmp) {\n\n    for (int i = 0; i < n; i++) {\n\ty[i] = 0.0;\n    }\n\n    for (int i = 0; i < m; i++) {\n\ttmp[i] = 0.0;\n\tfor (int j = 0; j < n; j++) {\n\t    tmp[i] = tmp[i] + A[i][j] * x[j];\n\t}\n\n\tfor (int j = 0; j < n; j++) {\n\t    y[j] = y[j] + A[i][j] * tmp[i];\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_atax(int m, int n,\n\t\t std::vector<std::vector<double>>& A,\n\t\t std::vector<double>& x,\n\t\t std::vector<double>& y,\n\t\t std::vector<double>& tmp) {\n\n    for (int i = 0; i < n; i++) {\n\ty[i] = 0.0;\n    }\n\n    for (int i = 0; i < m; i++) {\n\ttmp[i] = 0.0;\n\tfor (int j = 0; j < n; j++) {\n\t    tmp[i] = tmp[i] + A[i][j] * x[j];\n\t}\n\n\tfor (int j = 0; j < n; j++) {\n\t    y[j] = y[j] + A[i][j] * tmp[i];\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "atax"
    },
    {
        "prompt": "#include <vector>\n\nvoid kernel_covariance(int m, int n, \n\t\t       std::vector<std::vector<double>>& data,\n\t\t       std::vector<std::vector<double>>& cov,\n\t\t       std::vector<double>& mean) {\n\n    for (int j = 0; j < m; j++) {\n\tmean[j] = 0.0;\n        for (int i = 0; i < n; i++) {\n            mean[j] += data[i][j];\n        }\n        mean[j] /= n;\n    }\n\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < m; j++) {\n\t    data[i][j] -= mean[j];\n\t}\n    }\n\n    for (int i = 0; i < m; i++) {\n\tfor (int j = i; j < m; j++) {\n\t    cov[i][j] = 0.0;\n\t    for (int k = 0; k < n; k++) {\n\t\tcov[i][j] += data[k][i] * data[k][j];\n\t    }\n\t    cov[i][j] /= (n - 1.0);\n\t    cov[j][i] = cov[i][j];\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\nvoid kernel_covariance(int m, int n, \n\t\t       std::vector<std::vector<double>>& data,\n\t\t       std::vector<std::vector<double>>& cov,\n\t\t       std::vector<double>& mean) {\n\n    for (int j = 0; j < m; j++) {\n\tmean[j] = 0.0;\n        for (int i = 0; i < n; i++) {\n            mean[j] += data[i][j];\n        }\n        mean[j] /= n;\n    }\n\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < m; j++) {\n\t    data[i][j] -= mean[j];\n\t}\n    }\n\n    for (int i = 0; i < m; i++) {\n\tfor (int j = i; j < m; j++) {\n\t    cov[i][j] = 0.0;\n\t    for (int k = 0; k < n; k++) {\n\t\tcov[i][j] += data[k][i] * data[k][j];\n\t    }\n\t    cov[i][j] /= (n - 1.0);\n\t    cov[j][i] = cov[i][j];\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "covariance"
    },
    {
        "prompt": "#include <vector>\n\nvoid kernel_gemm(int ni, int nj, int nk,\n\t\t double alpha,\n\t\t double beta,\n\t\t std::vector<std::vector<double>>& A,\n\t\t std::vector<std::vector<double>>& B,\n\t\t std::vector<std::vector<double>>& C) {\n\n    // => Form C := alpha*A*B + beta*C,\n    //A is NIxNK\n    //B is NKxNJ\n    //C is NIxNJ\n    for (int i = 0; i < ni; i++) {\n\tfor (int j = 0; j < nj; j++) {\n\t    C[i][j] *= beta;\n\t}\n\tfor (int k = 0; k < nk; k++) {\n\t    for (int j = 0; j < nj; j++) {\n\t\tC[i][j] += alpha * A[i][k] * B[k][j];\n\t    }\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\nvoid kernel_gemm(int ni, int nj, int nk,\n\t\t double alpha,\n\t\t double beta,\n\t\t std::vector<std::vector<double>>& A,\n\t\t std::vector<std::vector<double>>& B,\n\t\t std::vector<std::vector<double>>& C) {\n\n    // => Form C := alpha*A*B + beta*C,\n    //A is NIxNK\n    //B is NKxNJ\n    //C is NIxNJ\n    for (int i = 0; i < ni; i++) {\n\tfor (int j = 0; j < nj; j++) {\n\t    C[i][j] *= beta;\n\t}\n\tfor (int k = 0; k < nk; k++) {\n\t    for (int j = 0; j < nj; j++) {\n\t\tC[i][j] += alpha * A[i][k] * B[k][j];\n\t    }\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "gemm"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_syr2k(int n, int m,\n\t\t  double alpha,\n\t\t  double beta,\n\t\t  std::vector<std::vector<double>>& C,\n\t\t  std::vector<std::vector<double>>& A,\n\t\t  std::vector<std::vector<double>>& B) {\n    //BLAS PARAMS\n    //UPLO  = 'L'\n    //TRANS = 'N'\n    //A is NxM\n    //B is NxM\n    //C is NxN\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j <= i; j++) {\n\t    C[i][j] *= beta;\n\t}\n\n\tfor (int k = 0; k < m; k++) {\n\t    for (int j = 0; j <= i; j++) {\n\t\tC[i][j] += A[j][k]*alpha*B[i][k] + B[j][k]*alpha*A[i][k];\n\t    }\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_syr2k(int n, int m,\n\t\t  double alpha,\n\t\t  double beta,\n\t\t  std::vector<std::vector<double>>& C,\n\t\t  std::vector<std::vector<double>>& A,\n\t\t  std::vector<std::vector<double>>& B) {\n    //BLAS PARAMS\n    //UPLO  = 'L'\n    //TRANS = 'N'\n    //A is NxM\n    //B is NxM\n    //C is NxN\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j <= i; j++) {\n\t    C[i][j] *= beta;\n\t}\n\n\tfor (int k = 0; k < m; k++) {\n\t    for (int j = 0; j <= i; j++) {\n\t\tC[i][j] += A[j][k]*alpha*B[i][k] + B[j][k]*alpha*A[i][k];\n\t    }\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "syr2k"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_doitgen(int nr, int nq, int np,\n\t\t    std::vector<std::vector<std::vector<double>>>& A,\n\t\t    std::vector<std::vector<double>>& C4,\n\t\t    std::vector<double>& sum) {\n\n    for (int r = 0; r < nr; r++) {\n\tfor (int q = 0; q < nq; q++) {\n\t    for (int p = 0; p < np; p++) {\n\t\tsum[p] = 0.0;\n\t\tfor (int s = 0; s < np; s++) {\n\t\t    sum[p] += A[r][q][s] * C4[s][p];\n\t\t}\n\t    }\n\n\t    for (int p = 0; p < np; p++) {\n\t\tA[r][q][p] = sum[p];\n\t    }\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_doitgen(int nr, int nq, int np,\n\t\t    std::vector<std::vector<std::vector<double>>>& A,\n\t\t    std::vector<std::vector<double>>& C4,\n\t\t    std::vector<double>& sum) {\n\n    for (int r = 0; r < nr; r++) {\n\tfor (int q = 0; q < nq; q++) {\n\t    for (int p = 0; p < np; p++) {\n\t\tsum[p] = 0.0;\n\t\tfor (int s = 0; s < np; s++) {\n\t\t    sum[p] += A[r][q][s] * C4[s][p];\n\t\t}\n\t    }\n\n\t    for (int p = 0; p < np; p++) {\n\t\tA[r][q][p] = sum[p];\n\t    }\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "doitgen"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/*\n  Original version by Dave Wonnacott at Haverford College <davew@cs.haverford.edu>,\n  with help from Allison Lake, Ting Zhou, and Tian Jin,\n  based on algorithm by Nussinov, described in Allison Lake's senior thesis.\n*/\n\nvoid kernel_nussinov(int n, std::vector<int>& seq,\n\t\t     std::vector<std::vector<int>>& table) {\n\n    auto match = [](int b1, int b2) {\n\treturn b1 + b2 == 3 ? 1 : 0;\n    };\n\n    for (int i = n - 1; i >= 0; i--) {\n\tfor (int j = i + 1; j < n; j++) {\n\t    if (j - 1 >= 0) {\n\t\ttable[i][j] = std::max<int>(table[i][j], table[i][j-1]);\n\t    }\n\t    if (i + 1 < n) {\n\t      table[i][j] = std::max<int>(table[i][j], table[i+1][j]);\n\t    }\n\n\t    if (j - 1 >= 0 && i + 1 < n) {\n\t\tif (i<j-1) {\n\t\t    table[i][j] = std::max<int>(table[i][j], table[i+1][j-1] + match(seq[i], seq[j]));\n\t\t} else {\n\t\t    table[i][j] = std::max<int>(table[i][j], table[i+1][j-1]);\n\t\t}\n\t    }\n\n\t    for (int k = i + 1; k < j; k++) {\n\t\ttable[i][j] = std::max<int>(table[i][j], table[i][k] + table[k+1][j]);\n\t    }\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/*\n  Original version by Dave Wonnacott at Haverford College <davew@cs.haverford.edu>,\n  with help from Allison Lake, Ting Zhou, and Tian Jin,\n  based on algorithm by Nussinov, described in Allison Lake's senior thesis.\n*/\n\nvoid kernel_nussinov(int n, std::vector<int>& seq,\n\t\t     std::vector<std::vector<int>>& table) {\n\n    auto match = [](int b1, int b2) {\n\treturn b1 + b2 == 3 ? 1 : 0;\n    };\n\n    for (int i = n - 1; i >= 0; i--) {\n\tfor (int j = i + 1; j < n; j++) {\n\t    if (j - 1 >= 0) {\n\t\ttable[i][j] = std::max<int>(table[i][j], table[i][j-1]);\n\t    }\n\t    if (i + 1 < n) {\n\t      table[i][j] = std::max<int>(table[i][j], table[i+1][j]);\n\t    }\n\n\t    if (j - 1 >= 0 && i + 1 < n) {\n\t\tif (i<j-1) {\n\t\t    table[i][j] = std::max<int>(table[i][j], table[i+1][j-1] + match(seq[i], seq[j]));\n\t\t} else {\n\t\t    table[i][j] = std::max<int>(table[i][j], table[i+1][j-1]);\n\t\t}\n\t    }\n\n\t    for (int k = i + 1; k < j; k++) {\n\t\ttable[i][j] = std::max<int>(table[i][j], table[i][k] + table[k+1][j]);\n\t    }\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "nussinov"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/* Based on a Fortran code fragment from Figure 5 of\n * \"Automatic Data and Computation Decomposition on Distributed Memory Parallel Computers\"\n * by Peizong Lee and Zvi Meir Kedem, TOPLAS, 2002\n */\nvoid kernel_adi(int tsteps, int n,\n\t\tstd::vector<std::vector<double>>& u,\n\t\tstd::vector<std::vector<double>>& v,\n\t\tstd::vector<std::vector<double>>& p,\n\t\tstd::vector<std::vector<double>>& q) {\n    double DX = 1.0 / n;\n    double DY = 1.0 / n;\n    double DT = 1.0 / tsteps;\n    double B1 = 2.0;\n    double B2 = 1.0;\n    double mul1 = B1 * DT / (DX * DX);\n    double mul2 = B2 * DT / (DY * DY);\n    double a = -mul1 / 2.0;\n    double b = 1.0 + mul1;\n    double c = a;\n    double d = -mul2 / 2.0;\n    double e = 1.0 + mul2;\n    double f = d;\n\n    for (int t = 1; t <= tsteps; t++) {\n\tfor (int i = 1; i < n - 1; i++) {\n\t    v[0][i] = 1.0;\n\t    p[i][0] = 0.0;\n\t    q[i][0] = v[0][i];\n\n\t    for (int j = 1; j < n - 1; j++) {\n\t\tp[i][j] = -c / (a * p[i][j-1] + b);\n\t\tq[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n\t    }\n\n\t    v[n - 1][i] = 1.0;\n\n\t    for (int j = n - 2; j >= 1; j--) {\n\t\tv[j][i] = p[i][j] * v[j + 1][i] + q[i][j];\n\t    }\n\t}\n\n\tfor (int i = 1; i < n - 1; i++) {\n\t    u[i][0] = 1.0;\n\t    p[i][0] = 0.0;\n\t    q[i][0] = u[i][0];\n\n\t    for (int j = 1; j < n - 1; j++) {\n\t\tp[i][j] = -f / (d * p[i][j - 1] + e);\n\t\tq[i][j] = (-a * v[i-1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n\t    }\n\n\t    u[i][n - 1] = 1.0;\n\t    for (int j = n - 2; j >= 1; j--) {\n\t\tu[i][j] = p[i][j] * u[i][j + 1] + q[i][j];\n\t    }\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/* Based on a Fortran code fragment from Figure 5 of\n * \"Automatic Data and Computation Decomposition on Distributed Memory Parallel Computers\"\n * by Peizong Lee and Zvi Meir Kedem, TOPLAS, 2002\n */\nvoid kernel_adi(int tsteps, int n,\n\t\tstd::vector<std::vector<double>>& u,\n\t\tstd::vector<std::vector<double>>& v,\n\t\tstd::vector<std::vector<double>>& p,\n\t\tstd::vector<std::vector<double>>& q) {\n    double DX = 1.0 / n;\n    double DY = 1.0 / n;\n    double DT = 1.0 / tsteps;\n    double B1 = 2.0;\n    double B2 = 1.0;\n    double mul1 = B1 * DT / (DX * DX);\n    double mul2 = B2 * DT / (DY * DY);\n    double a = -mul1 / 2.0;\n    double b = 1.0 + mul1;\n    double c = a;\n    double d = -mul2 / 2.0;\n    double e = 1.0 + mul2;\n    double f = d;\n\n    for (int t = 1; t <= tsteps; t++) {\n\tfor (int i = 1; i < n - 1; i++) {\n\t    v[0][i] = 1.0;\n\t    p[i][0] = 0.0;\n\t    q[i][0] = v[0][i];\n\n\t    for (int j = 1; j < n - 1; j++) {\n\t\tp[i][j] = -c / (a * p[i][j-1] + b);\n\t\tq[i][j] = (-d * u[j][i - 1] + (1.0 + 2.0 * d) * u[j][i] - f * u[j][i + 1] - a * q[i][j - 1]) / (a * p[i][j - 1] + b);\n\t    }\n\n\t    v[n - 1][i] = 1.0;\n\n\t    for (int j = n - 2; j >= 1; j--) {\n\t\tv[j][i] = p[i][j] * v[j + 1][i] + q[i][j];\n\t    }\n\t}\n\n\tfor (int i = 1; i < n - 1; i++) {\n\t    u[i][0] = 1.0;\n\t    p[i][0] = 0.0;\n\t    q[i][0] = u[i][0];\n\n\t    for (int j = 1; j < n - 1; j++) {\n\t\tp[i][j] = -f / (d * p[i][j - 1] + e);\n\t\tq[i][j] = (-a * v[i-1][j] + (1.0 + 2.0 * a) * v[i][j] - c * v[i + 1][j] - d * q[i][j - 1]) / (d * p[i][j - 1] + e);\n\t    }\n\n\t    u[i][n - 1] = 1.0;\n\t    for (int j = n - 2; j >= 1; j--) {\n\t\tu[i][j] = p[i][j] * u[i][j + 1] + q[i][j];\n\t    }\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "adi"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_heat_3d(int tsteps,\n\t\t    int n,\n\t\t    std::vector<std::vector<std::vector<double>>>& A,\n\t\t    std::vector<std::vector<std::vector<double>>>& B) {\n\n    for (int t = 1; t <= tsteps; t++) {\n        for (int i = 1; i < n - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                for (int k = 1; k < n - 1; k++) {\n                    B[i][j][k] = 0.125 * (A[i+1][j][k] - 2.0 * A[i][j][k] + A[i-1][j][k]) + 0.125 * (A[i][j+1][k] - 2.0 * A[i][j][k] + A[i][j-1][k]) + 0.125 * (A[i][j][k+1] - 2.0 * A[i][j][k] + A[i][j][k-1]) + A[i][j][k];\n                }\n            }\n        }\n\n        for (int i = 1; i < n - 1; i++) {\n           for (int j = 1; j < n - 1; j++) {\n               for (int k = 1; k < n - 1; k++) {\n                   A[i][j][k] = 0.125 * (B[i+1][j][k] - 2.0 * B[i][j][k] + B[i-1][j][k]) + 0.125 * (B[i][j+1][k] - 2.0 * B[i][j][k] + B[i][j-1][k]) + 0.125 * (B[i][j][k+1] - 2.0 * B[i][j][k] + B[i][j][k-1]) + B[i][j][k];\n               }\n           }\n       }\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_heat_3d(int tsteps,\n\t\t    int n,\n\t\t    std::vector<std::vector<std::vector<double>>>& A,\n\t\t    std::vector<std::vector<std::vector<double>>>& B) {\n\n    for (int t = 1; t <= tsteps; t++) {\n        for (int i = 1; i < n - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                for (int k = 1; k < n - 1; k++) {\n                    B[i][j][k] = 0.125 * (A[i+1][j][k] - 2.0 * A[i][j][k] + A[i-1][j][k]) + 0.125 * (A[i][j+1][k] - 2.0 * A[i][j][k] + A[i][j-1][k]) + 0.125 * (A[i][j][k+1] - 2.0 * A[i][j][k] + A[i][j][k-1]) + A[i][j][k];\n                }\n            }\n        }\n\n        for (int i = 1; i < n - 1; i++) {\n           for (int j = 1; j < n - 1; j++) {\n               for (int k = 1; k < n - 1; k++) {\n                   A[i][j][k] = 0.125 * (B[i+1][j][k] - 2.0 * B[i][j][k] + B[i-1][j][k]) + 0.125 * (B[i][j+1][k] - 2.0 * B[i][j][k] + B[i][j-1][k]) + 0.125 * (B[i][j][k+1] - 2.0 * B[i][j][k] + B[i][j][k-1]) + B[i][j][k];\n               }\n           }\n       }\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "heat_3d"
    },
    {
        "prompt": "#include <vector>\n    \n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_gesummv(int n,\n\t\t    double alpha,\n\t\t    double beta,\n\t\t    std::vector<std::vector<double>>& A,\n\t\t    std::vector<std::vector<double>>& B,\n\t\t    std::vector<double>& tmp,\n\t\t    std::vector<double>& x,\n\t\t    std::vector<double>& y) {\n\n    for (int i = 0; i < n; i++) {\n\ttmp[i] = 0.0;\n\ty[i] = 0.0;\n\tfor (int j = 0; j < n; j++) {\n\t    tmp[i] = A[i][j] * x[j] + tmp[i];\n\t    y[i] = B[i][j] * x[j] + y[i];\n\t}\n\t\n\ty[i] = alpha * tmp[i] + beta * y[i];\n    }\n}\n\n",
        "src_code": "#include <vector>\n    \n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_gesummv(int n,\n\t\t    double alpha,\n\t\t    double beta,\n\t\t    std::vector<std::vector<double>>& A,\n\t\t    std::vector<std::vector<double>>& B,\n\t\t    std::vector<double>& tmp,\n\t\t    std::vector<double>& x,\n\t\t    std::vector<double>& y) {\n\n    for (int i = 0; i < n; i++) {\n\ttmp[i] = 0.0;\n\ty[i] = 0.0;\n\tfor (int j = 0; j < n; j++) {\n\t    tmp[i] = A[i][j] * x[j] + tmp[i];\n\t    y[i] = B[i][j] * x[j] + y[i];\n\t}\n\t\n\ty[i] = alpha * tmp[i] + beta * y[i];\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "gesummv"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_trisolv(int n,\n\t\t    std::vector<std::vector<double>>& L,\n\t\t    std::vector<double>& x,\n\t\t    std::vector<double>& b) {\n    for (int i = 0; i < n; i++) {\n\tx[i] = b[i];\n\tfor (int j = 0; j < i; j++) {\n\t    x[i] -= L[i][j] * x[j];\n\t}\n\tx[i] = x[i] / L[i][i];\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_trisolv(int n,\n\t\t    std::vector<std::vector<double>>& L,\n\t\t    std::vector<double>& x,\n\t\t    std::vector<double>& b) {\n    for (int i = 0; i < n; i++) {\n\tx[i] = b[i];\n\tfor (int j = 0; j < i; j++) {\n\t    x[i] -= L[i][j] * x[j];\n\t}\n\tx[i] = x[i] / L[i][i];\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "trisolv"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_durbin(int n,\n\t\t   std::vector<double>& r,\n\t\t   std::vector<double>& y) {\n\n    std::vector<double> z(n, 0.0);\n    y[0] = -r[0];\n    double beta = 1.0;\n    double alpha = -r[0];\n\n    for (int k = 1; k < n; k++) {\n\tbeta = (1 - alpha * alpha) * beta;\n\tdouble sum = 0.0;\n\tfor (int i = 0; i < k; i++) {\n\t    sum += r[k - i - 1] * y[i];\n\t}\n\n\talpha = -(r[k] + sum) / beta;\n\n\tfor (int i = 0; i < k; i++) {\n\t    z[i] = y[i] + alpha * y[k - i - 1];\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t    y[i] = z[i];\n\t}\n\n\ty[k] = alpha;\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_durbin(int n,\n\t\t   std::vector<double>& r,\n\t\t   std::vector<double>& y) {\n\n    std::vector<double> z(n, 0.0);\n    y[0] = -r[0];\n    double beta = 1.0;\n    double alpha = -r[0];\n\n    for (int k = 1; k < n; k++) {\n\tbeta = (1 - alpha * alpha) * beta;\n\tdouble sum = 0.0;\n\tfor (int i = 0; i < k; i++) {\n\t    sum += r[k - i - 1] * y[i];\n\t}\n\n\talpha = -(r[k] + sum) / beta;\n\n\tfor (int i = 0; i < k; i++) {\n\t    z[i] = y[i] + alpha * y[k - i - 1];\n\t}\n\n\tfor (int i = 0; i < k; i++) {\n\t    y[i] = z[i];\n\t}\n\n\ty[k] = alpha;\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "durbin"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_bicg(int m, int n,\n\t\t std::vector<std::vector<double>>& A,\n\t\t std::vector<double>& s,\n\t\t std::vector<double>& q,\n\t\t std::vector<double>& p,\n\t\t std::vector<double>& r) {\n    for (int i = 0; i < m; i++) {\n\ts[i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n\tq[i] = 0.0;\n\tfor (int j = 0; j < m; j++) {\n\t    s[j] = s[j] + r[i] * A[i][j];\n\t    q[i] = q[i] + A[i][j] + p[j];\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_bicg(int m, int n,\n\t\t std::vector<std::vector<double>>& A,\n\t\t std::vector<double>& s,\n\t\t std::vector<double>& q,\n\t\t std::vector<double>& p,\n\t\t std::vector<double>& r) {\n    for (int i = 0; i < m; i++) {\n\ts[i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n\tq[i] = 0.0;\n\tfor (int j = 0; j < m; j++) {\n\t    s[j] = s[j] + r[i] * A[i][j];\n\t    q[i] = q[i] + A[i][j] + p[j];\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "bicg"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_3mm(int ni, int nj, int nk, int nl, int nm,\n\t\tstd::vector<std::vector<double>>& E,\n\t\tstd::vector<std::vector<double>>& A,\n\t\tstd::vector<std::vector<double>>& B,\n\t\tstd::vector<std::vector<double>>& F,\n\t\tstd::vector<std::vector<double>>& C,\n\t\tstd::vector<std::vector<double>>& D,\n\t\tstd::vector<std::vector<double>>& G) {\n\n    for (int i = 0; i < ni; i++) {\n\tfor (int j = 0; j < nj; j++) {\n\t    E[i][j] = 0.0;\n\t    for (int k = 0; k < nk; k++) {\n\t\tE[i][j] += A[i][k] * B[k][j];\n\t    }\n\t}\n    }\n\n    for (int i = 0; i < nj; i++) {\n\tfor (int j = 0; j < nl; j++) {\n\t    F[i][j] = 0.0;\n\t    for (int k = 0; k < nm; k++) {\n\t\tF[i][j] += C[i][k]  * D[k][j];\n\t    }\n\t}\n    }\n\n    for (int i = 0; i < ni; i++) {\n\tfor (int j = 0; j < nl; j++) {\n\t    G[i][j] = 0.0;\n\t    for (int k = 0; k < nj; k++) {\n\t\tG[i][j] += E[i][k] * F[k][j];\n\t    }\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_3mm(int ni, int nj, int nk, int nl, int nm,\n\t\tstd::vector<std::vector<double>>& E,\n\t\tstd::vector<std::vector<double>>& A,\n\t\tstd::vector<std::vector<double>>& B,\n\t\tstd::vector<std::vector<double>>& F,\n\t\tstd::vector<std::vector<double>>& C,\n\t\tstd::vector<std::vector<double>>& D,\n\t\tstd::vector<std::vector<double>>& G) {\n\n    for (int i = 0; i < ni; i++) {\n\tfor (int j = 0; j < nj; j++) {\n\t    E[i][j] = 0.0;\n\t    for (int k = 0; k < nk; k++) {\n\t\tE[i][j] += A[i][k] * B[k][j];\n\t    }\n\t}\n    }\n\n    for (int i = 0; i < nj; i++) {\n\tfor (int j = 0; j < nl; j++) {\n\t    F[i][j] = 0.0;\n\t    for (int k = 0; k < nm; k++) {\n\t\tF[i][j] += C[i][k]  * D[k][j];\n\t    }\n\t}\n    }\n\n    for (int i = 0; i < ni; i++) {\n\tfor (int j = 0; j < nl; j++) {\n\t    G[i][j] = 0.0;\n\t    for (int k = 0; k < nj; k++) {\n\t\tG[i][j] += E[i][k] * F[k][j];\n\t    }\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "3mm"
    },
    {
        "prompt": "\n#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_symm(int m, int n,\n\t\t double alpha,\n\t\t double beta,\n\t\t std::vector<std::vector<double>>& C,\n\t\t std::vector<std::vector<double>>& A,\n\t\t std::vector<std::vector<double>>& B) {\n\n    // =>  Form  C := alpha*A*B + beta*C\n    // A is MxM\n    // B is MxN\n    // C is MxN\n    //note that due to Fortran array layout, the code below more closely resembles upper triangular case in BLAS\n    for (int i = 0; i < m; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    double temp2 = 0;\n\t    for (int k = 0; k < i; k++) {\n\t\tC[k][j] += alpha * B[i][j] * A[i][k];\n\t\ttemp2 += B[k][j] * A[i][k];\n\t    }\n\t    C[i][j] = beta * C[i][j] + alpha*B[i][j] * A[i][i] + alpha * temp2;\n\t}\n    }\n}\n\n",
        "src_code": "\n#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_symm(int m, int n,\n\t\t double alpha,\n\t\t double beta,\n\t\t std::vector<std::vector<double>>& C,\n\t\t std::vector<std::vector<double>>& A,\n\t\t std::vector<std::vector<double>>& B) {\n\n    // =>  Form  C := alpha*A*B + beta*C\n    // A is MxM\n    // B is MxN\n    // C is MxN\n    //note that due to Fortran array layout, the code below more closely resembles upper triangular case in BLAS\n    for (int i = 0; i < m; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    double temp2 = 0;\n\t    for (int k = 0; k < i; k++) {\n\t\tC[k][j] += alpha * B[i][j] * A[i][k];\n\t\ttemp2 += B[k][j] * A[i][k];\n\t    }\n\t    C[i][j] = beta * C[i][j] + alpha*B[i][j] * A[i][i] + alpha * temp2;\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "symm"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_syrk(int n, int m,\n\t\t double alpha,\n\t\t double beta,\n\t\t std::vector<std::vector<double>>& C,\n\t\t std::vector<std::vector<double>>& A) {\n\n    // =>  Form  C := alpha*A*A**T + beta*C.\n    //A is NxM\n    //C is NxN\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j <= i; j++) {\n\t    C[i][j] *= beta;\n\t}\n\tfor (int k = 0; k < m; k++) {\n\t    for (int j = 0; j <= i; j++) {\n\t\tC[i][j] += alpha * A[i][k] * A[j][k];\n\t    }\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_syrk(int n, int m,\n\t\t double alpha,\n\t\t double beta,\n\t\t std::vector<std::vector<double>>& C,\n\t\t std::vector<std::vector<double>>& A) {\n\n    // =>  Form  C := alpha*A*A**T + beta*C.\n    //A is NxM\n    //C is NxN\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j <= i; j++) {\n\t    C[i][j] *= beta;\n\t}\n\tfor (int k = 0; k < m; k++) {\n\t    for (int j = 0; j <= i; j++) {\n\t\tC[i][j] += alpha * A[i][k] * A[j][k];\n\t    }\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "syrk"
    },
    {
        "prompt": "#include <numeric>\n#include <vector>\n\nvoid kernel_correlation(int m, int n,\n\t\t\tstd::vector<std::vector<double>>& data,\n\t\t\tstd::vector<std::vector<double>>& corr,\n\t\t\tstd::vector<double>& mean,\n\t\t\tstd::vector<double>& stddev) {\n    double eps = 0.1;\n\n    for (int j = 0; j < m; j++) {\n        mean[j] = 0.0;\n        for (int i = 0; i < n; i++) {\n            mean[j] += data[i][j];\n        }\n        mean[j] /= n;\n    }\n\n    for (int j = 0; j < m; j++) {\n        stddev[j] = 0.0;\n        for (int i = 0; i < n; i++) {\n            stddev[j] += (data[i][j] - mean[j]) * (data[i][j] - mean[j]);\n        }\n        stddev[j] /= n;\n        stddev[j] = std::sqrt(stddev[j]);\n        /* The following in an inelegant but usual way to handle\n        near-zero std. dev. values, which below would cause a zero-\n        divide. */\n        stddev[j] = stddev[j] <= eps ? 1.0 : stddev[j];\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            data[i][j] -= mean[j];\n            data[i][j] /= std::sqrt(n) * stddev[j];\n        }\n    }\n\n    for (int i = 0; i < m - 1; i++) {\n        corr[i][i] = 1.0;\n        for (int j = i + 1; j < m; j++) {\n            corr[i][j] = 0.0;\n            for (int k = 0; k < n; k++) {\n                corr[i][j] += (data[k][i] * data[k][j]);\n            }\n            corr[j][i] = corr[i][j];\n        }\n    }\n\n    corr[m-1][m-1] = 1.0;\n}\n\n",
        "src_code": "#include <numeric>\n#include <vector>\n\nvoid kernel_correlation(int m, int n,\n\t\t\tstd::vector<std::vector<double>>& data,\n\t\t\tstd::vector<std::vector<double>>& corr,\n\t\t\tstd::vector<double>& mean,\n\t\t\tstd::vector<double>& stddev) {\n    double eps = 0.1;\n\n    for (int j = 0; j < m; j++) {\n        mean[j] = 0.0;\n        for (int i = 0; i < n; i++) {\n            mean[j] += data[i][j];\n        }\n        mean[j] /= n;\n    }\n\n    for (int j = 0; j < m; j++) {\n        stddev[j] = 0.0;\n        for (int i = 0; i < n; i++) {\n            stddev[j] += (data[i][j] - mean[j]) * (data[i][j] - mean[j]);\n        }\n        stddev[j] /= n;\n        stddev[j] = std::sqrt(stddev[j]);\n        /* The following in an inelegant but usual way to handle\n        near-zero std. dev. values, which below would cause a zero-\n        divide. */\n        stddev[j] = stddev[j] <= eps ? 1.0 : stddev[j];\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            data[i][j] -= mean[j];\n            data[i][j] /= std::sqrt(n) * stddev[j];\n        }\n    }\n\n    for (int i = 0; i < m - 1; i++) {\n        corr[i][i] = 1.0;\n        for (int j = i + 1; j < m; j++) {\n            corr[i][j] = 0.0;\n            for (int k = 0; k < n; k++) {\n                corr[i][j] += (data[k][i] * data[k][j]);\n            }\n            corr[j][i] = corr[i][j];\n        }\n    }\n\n    corr[m-1][m-1] = 1.0;\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "correlation"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_2mm(int ni, int nj, int nk, int nl,\n\t\tdouble alpha,\n\t\tdouble beta,\n\t\tstd::vector<std::vector<double>>& tmp,\n\t\tstd::vector<std::vector<double>>& A,\n\t\tstd::vector<std::vector<double>>& B,\n\t\tstd::vector<std::vector<double>>& C,\n\t\tstd::vector<std::vector<double>>& D) {\n\n    for (int i = 0; i < ni; i++) {\n\tfor (int j = 0; j < nj; j++) {\n\t    tmp[i][j] = 0.0;\n\t    for (int k = 0; k < nk; k++) {\n\t\ttmp[i][j] += alpha * A[i][k] * B[k][j];\n\t    }\n\t}\n    }\n\n    for (int i = 0; i < ni; i++) {\n\tfor (int j = 0; j < nl; j++) {\n\t    D[i][j] *= beta;\n\t    for (int k = 0; k < nj; k++) {\n\t\tD[i][j] += tmp[i][k] * C[k][j];\n\t    }\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_2mm(int ni, int nj, int nk, int nl,\n\t\tdouble alpha,\n\t\tdouble beta,\n\t\tstd::vector<std::vector<double>>& tmp,\n\t\tstd::vector<std::vector<double>>& A,\n\t\tstd::vector<std::vector<double>>& B,\n\t\tstd::vector<std::vector<double>>& C,\n\t\tstd::vector<std::vector<double>>& D) {\n\n    for (int i = 0; i < ni; i++) {\n\tfor (int j = 0; j < nj; j++) {\n\t    tmp[i][j] = 0.0;\n\t    for (int k = 0; k < nk; k++) {\n\t\ttmp[i][j] += alpha * A[i][k] * B[k][j];\n\t    }\n\t}\n    }\n\n    for (int i = 0; i < ni; i++) {\n\tfor (int j = 0; j < nl; j++) {\n\t    D[i][j] *= beta;\n\t    for (int k = 0; k < nj; k++) {\n\t\tD[i][j] += tmp[i][k] * C[k][j];\n\t    }\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "2mm"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_mvt(int n,\n\t\tstd::vector<double>& x1,\n\t\tstd::vector<double>& x2,\n\t\tstd::vector<double>& y_1,\n\t\tstd::vector<double>& y_2,\n\t\tstd::vector<std::vector<double>>& A) {\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    x1[i] = x1[i] + A[i][j] * y_1[j];\n\t}\n    }\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    x2[i] = x2[i] + A[j][i] * y_2[j];\n\t}\n    }\n}\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_mvt(int n,\n\t\tstd::vector<double>& x1,\n\t\tstd::vector<double>& x2,\n\t\tstd::vector<double>& y_1,\n\t\tstd::vector<double>& y_2,\n\t\tstd::vector<std::vector<double>>& A) {\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    x1[i] = x1[i] + A[i][j] * y_1[j];\n\t}\n    }\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    x2[i] = x2[i] + A[j][i] * y_2[j];\n\t}\n    }\n}\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "mvt"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_jacobi_1d(int tsteps,\n\t\t      int n,\n\t\t      std::vector<double>& A,\n\t\t      std::vector<double>& B) {\n    for (int t = 0; t < tsteps; t++) {\n\tfor (int i = 1; i < n - 1; i++) {\n\t    B[i] = 0.33333 * (A[i-1] + A[i] + A[i + 1]);\n\t}\n\tfor (int i = 1; i < n - 1; i++) {\n\t    A[i] = 0.33333 * (B[i-1] + B[i] + B[i + 1]);\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_jacobi_1d(int tsteps,\n\t\t      int n,\n\t\t      std::vector<double>& A,\n\t\t      std::vector<double>& B) {\n    for (int t = 0; t < tsteps; t++) {\n\tfor (int i = 1; i < n - 1; i++) {\n\t    B[i] = 0.33333 * (A[i-1] + A[i] + A[i + 1]);\n\t}\n\tfor (int i = 1; i < n - 1; i++) {\n\t    A[i] = 0.33333 * (B[i-1] + B[i] + B[i + 1]);\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "jacobi_1d"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_ludcmp(int n,\n\t\t   std::vector<std::vector<double>>& A,\n\t\t   std::vector<double>& b,\n\t\t   std::vector<double>& x,\n\t\t   std::vector<double>& y) {\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < i; j++) {\n\t    double w = A[i][j];\n\t    for (int k = 0; k < j; k++) {\n\t\tw -= A[i][k] * A[k][j];\n\t    }\n\t    A[i][j] = w / A[j][j];\n\t}\n\n\tfor (int j = i; j < n; j++) {\n\t    double w = A[i][j];\n\t    for (int k = 0; k < i; k++) {\n\t\tw -= A[i][k] * A[k][j];\n\t    }\n\n\t    A[i][j] = w;\n\t}\n    }\n\n    for (int i = 0; i < n; i++) {\n\tdouble w = b[i];\n\tfor (int j = 0; j < i; j++) {\n\t    w -= A[i][j] * y[j];\n\t}\n\ty[i] = w;\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n\tdouble w = y[i];\n\tfor (int j = i + 1; j < n; j++) {\n\t    w -= A[i][j] * x[j];\n\t}\n\tx[i] = w / A[i][i];\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_ludcmp(int n,\n\t\t   std::vector<std::vector<double>>& A,\n\t\t   std::vector<double>& b,\n\t\t   std::vector<double>& x,\n\t\t   std::vector<double>& y) {\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < i; j++) {\n\t    double w = A[i][j];\n\t    for (int k = 0; k < j; k++) {\n\t\tw -= A[i][k] * A[k][j];\n\t    }\n\t    A[i][j] = w / A[j][j];\n\t}\n\n\tfor (int j = i; j < n; j++) {\n\t    double w = A[i][j];\n\t    for (int k = 0; k < i; k++) {\n\t\tw -= A[i][k] * A[k][j];\n\t    }\n\n\t    A[i][j] = w;\n\t}\n    }\n\n    for (int i = 0; i < n; i++) {\n\tdouble w = b[i];\n\tfor (int j = 0; j < i; j++) {\n\t    w -= A[i][j] * y[j];\n\t}\n\ty[i] = w;\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n\tdouble w = y[i];\n\tfor (int j = i + 1; j < n; j++) {\n\t    w -= A[i][j] * x[j];\n\t}\n\tx[i] = w / A[i][i];\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "ludcmp"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_fdtd_2d(int tmax,\n\t\t    int nx,\n\t\t    int ny,\n\t\t    std::vector<std::vector<double>>& ex,\n\t\t    std::vector<std::vector<double>>& ey,\n\t\t    std::vector<std::vector<double>>& hz,\n\t\t    std::vector<double>& _fict_) {\n    for (int t = 0; t < tmax; t++) {\n\tfor (int j = 0; j < ny; j++) {\n\t    ey[0][j] = _fict_[t];\n\t}\n\n\tfor (int i = 1; i < nx; i++) {\n\t    for (int j = 0; j < ny; j++) {\n\t\tey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n\t    }\n\t}\n\n\tfor (int i = 0; i < nx; i++) {\n\t    for (int j = 1; j < ny; j++) {\n\t\tex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n\t    }\n\t}\n\n\tfor (int i = 0; i < nx - 1; i++) {\n\t    for (int j = 0; j < ny - 1; j++) {\n\t\thz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n\t    }\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_fdtd_2d(int tmax,\n\t\t    int nx,\n\t\t    int ny,\n\t\t    std::vector<std::vector<double>>& ex,\n\t\t    std::vector<std::vector<double>>& ey,\n\t\t    std::vector<std::vector<double>>& hz,\n\t\t    std::vector<double>& _fict_) {\n    for (int t = 0; t < tmax; t++) {\n\tfor (int j = 0; j < ny; j++) {\n\t    ey[0][j] = _fict_[t];\n\t}\n\n\tfor (int i = 1; i < nx; i++) {\n\t    for (int j = 0; j < ny; j++) {\n\t\tey[i][j] = ey[i][j] - 0.5 * (hz[i][j] - hz[i - 1][j]);\n\t    }\n\t}\n\n\tfor (int i = 0; i < nx; i++) {\n\t    for (int j = 1; j < ny; j++) {\n\t\tex[i][j] = ex[i][j] - 0.5 * (hz[i][j] - hz[i][j - 1]);\n\t    }\n\t}\n\n\tfor (int i = 0; i < nx - 1; i++) {\n\t    for (int j = 0; j < ny - 1; j++) {\n\t\thz[i][j] = hz[i][j] - 0.7 * (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);\n\t    }\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "fdtd_2d"
    },
    {
        "prompt": "#include <cmath>\n#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/* QR Decomposition with Modified Gram Schmidt:\n http://www.inf.ethz.ch/personal/gander/ */\nvoid kernel_gramschmidt(int m, int n,\n\t\t\tstd::vector<std::vector<double>>& A,\n\t\t\tstd::vector<std::vector<double>>& R,\n\t\t\tstd::vector<std::vector<double>>& Q) {\n    for (int k = 0; k < n; k++) {\n\tdouble nrm = 0.0;\n\tfor (int i = 0; i < m; i++) {\n\t    nrm += A[i][k] * A[i][k];\n\t}\n\tR[k][k] = std::sqrt(nrm);\n\tfor (int i = 0; i < m; i++) {\n\t    Q[i][k] = A[i][k] / R[k][k];\n\t}\n\tfor (int j = k + 1; j < n; j++) {\n\t    R[k][j] = 0.0;\n\t    for (int i = 0; i < m; i++) {\n\t\tR[k][j] += Q[i][k] * A[i][j];\n\t    }\n\t    for (int i = 0; i < m; i++) {\n\t\tA[i][j] = A[i][j] - Q[i][k] * R[k][j];\n\t    }\n\t}\n    }\n}\n",
        "src_code": "#include <cmath>\n#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/* QR Decomposition with Modified Gram Schmidt:\n http://www.inf.ethz.ch/personal/gander/ */\nvoid kernel_gramschmidt(int m, int n,\n\t\t\tstd::vector<std::vector<double>>& A,\n\t\t\tstd::vector<std::vector<double>>& R,\n\t\t\tstd::vector<std::vector<double>>& Q) {\n    for (int k = 0; k < n; k++) {\n\tdouble nrm = 0.0;\n\tfor (int i = 0; i < m; i++) {\n\t    nrm += A[i][k] * A[i][k];\n\t}\n\tR[k][k] = std::sqrt(nrm);\n\tfor (int i = 0; i < m; i++) {\n\t    Q[i][k] = A[i][k] / R[k][k];\n\t}\n\tfor (int j = k + 1; j < n; j++) {\n\t    R[k][j] = 0.0;\n\t    for (int i = 0; i < m; i++) {\n\t\tR[k][j] += Q[i][k] * A[i][j];\n\t    }\n\t    for (int i = 0; i < m; i++) {\n\t\tA[i][j] = A[i][j] - Q[i][k] * R[k][j];\n\t    }\n\t}\n    }\n}\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "gramschmidt"
    },
    {
        "prompt": "#include <cmath>\n#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_cholesky(int n,\n\t\t     std::vector<std::vector<double>>& A) {\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < i; j++) {\n\t    for (int k = 0; k < j; k++) {\n\t\tA[i][j] -= A[i][k] * A[j][k];\n\t    }\n\t    A[i][j] /= A[j][j];\n\t}\n\t// i==j case\n\tfor (int k = 0; k < i; k++) {\n\t    A[i][i] -= A[i][k] * A[i][k];\n\t}\n\n\tA[i][i] = std::sqrt(A[i][i]);\n    }\n}\n\n",
        "src_code": "#include <cmath>\n#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_cholesky(int n,\n\t\t     std::vector<std::vector<double>>& A) {\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < i; j++) {\n\t    for (int k = 0; k < j; k++) {\n\t\tA[i][j] -= A[i][k] * A[j][k];\n\t    }\n\t    A[i][j] /= A[j][j];\n\t}\n\t// i==j case\n\tfor (int k = 0; k < i; k++) {\n\t    A[i][i] -= A[i][k] * A[i][k];\n\t}\n\n\tA[i][i] = std::sqrt(A[i][i]);\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "cholesky"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_jacobi_2d(int tsteps,\n\t\t      int n,\n\t\t      std::vector<std::vector<double>>& A,\n\t\t      std::vector<std::vector<double>>& B) {\n    for (int t = 0; t < tsteps; t++) {\n\tfor (int i = 1; i < n - 1; i++) {\n\t    for (int j = 1; j < n - 1; j++) {\n\t\tB[i][j] = 0.2 * (A[i][j] + A[i][j-1] + A[i][1+j] + A[1+i][j] + A[i-1][j]);\n\t    }\n\t}\n\tfor (int i = 1; i < n - 1; i++) {\n\t    for (int j = 1; j < n - 1; j++) {\n\t\tA[i][j] = 0.2 * (B[i][j] + B[i][j-1] + B[i][1+j] + B[1+i][j] + B[i-1][j]);\n\t    }\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_jacobi_2d(int tsteps,\n\t\t      int n,\n\t\t      std::vector<std::vector<double>>& A,\n\t\t      std::vector<std::vector<double>>& B) {\n    for (int t = 0; t < tsteps; t++) {\n\tfor (int i = 1; i < n - 1; i++) {\n\t    for (int j = 1; j < n - 1; j++) {\n\t\tB[i][j] = 0.2 * (A[i][j] + A[i][j-1] + A[i][1+j] + A[1+i][j] + A[i-1][j]);\n\t    }\n\t}\n\tfor (int i = 1; i < n - 1; i++) {\n\t    for (int j = 1; j < n - 1; j++) {\n\t\tA[i][j] = 0.2 * (B[i][j] + B[i][j-1] + B[i][1+j] + B[1+i][j] + B[i-1][j]);\n\t    }\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "jacobi_2d"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_seidel_2d(int tsteps,\n\t\t      int n,\n\t\t      std::vector<std::vector<double>>& A) {\n    for (int t = 0; t <= tsteps - 1; t++) {\n\tfor (int i = 1; i<= n - 2; i++) {\n\t    for (int j = 1; j <= n - 2; j++) {\n\t\tA[i][j] = (A[i-1][j-1] + A[i-1][j] + A[i-1][j+1] + A[i][j-1] + A[i][j] + A[i][j+1] + A[i+1][j-1] + A[i+1][j] + A[i+1][j+1]) / 9.0;\n\t    }\n\t }\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_seidel_2d(int tsteps,\n\t\t      int n,\n\t\t      std::vector<std::vector<double>>& A) {\n    for (int t = 0; t <= tsteps - 1; t++) {\n\tfor (int i = 1; i<= n - 2; i++) {\n\t    for (int j = 1; j <= n - 2; j++) {\n\t\tA[i][j] = (A[i-1][j-1] + A[i-1][j] + A[i-1][j+1] + A[i][j-1] + A[i][j] + A[i][j+1] + A[i+1][j-1] + A[i+1][j] + A[i+1][j+1]) / 9.0;\n\t    }\n\t }\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "seidel_2d"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_trmm(int m, int n,\n\t\t double alpha,\n\t\t std::vector<std::vector<double>>& A,\n\t\t std::vector<std::vector<double>>& B) {\n    // => Form  B := alpha*A**T*B.\n    // A is MxM\n    // B is MxN\n\n    for (int i = 0; i < m; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    for (int k = i + 1; k < m; k++) {\n\t\tB[i][j] += A[k][i] * B[k][j];\n\t    }\n\t    B[i][j] = alpha * B[i][j];\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_trmm(int m, int n,\n\t\t double alpha,\n\t\t std::vector<std::vector<double>>& A,\n\t\t std::vector<std::vector<double>>& B) {\n    // => Form  B := alpha*A**T*B.\n    // A is MxM\n    // B is MxN\n\n    for (int i = 0; i < m; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    for (int k = i + 1; k < m; k++) {\n\t\tB[i][j] += A[k][i] * B[k][j];\n\t    }\n\t    B[i][j] = alpha * B[i][j];\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "trmm"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_gemver(int n,\n\t\t   double alpha,\n\t\t   double beta,\n\t\t   std::vector<std::vector<double>>& A,\n\t\t   std::vector<double>& u1,\n\t\t   std::vector<double>& v1,\n\t\t   std::vector<double>& u2,\n\t\t   std::vector<double>& v2,\n\t\t   std::vector<double>& w,\n\t\t   std::vector<double>& x,\n\t\t   std::vector<double>& y,\n\t\t   std::vector<double>& z) {\n\t\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    A[i][j] = A[i][j] + u1[i] * v1[j] + u2[i] * v2[j];\n\t}\n    }\n\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    x[i] = x[i] + beta * A[j][i] * y[j];\n\t}\n    }\n\n    for (int i = 0; i < n; i++) {\n\tx[i] = x[i] + z[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    w[i] = w[i] +  alpha * A[i][j] * x[j];\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_gemver(int n,\n\t\t   double alpha,\n\t\t   double beta,\n\t\t   std::vector<std::vector<double>>& A,\n\t\t   std::vector<double>& u1,\n\t\t   std::vector<double>& v1,\n\t\t   std::vector<double>& u2,\n\t\t   std::vector<double>& v2,\n\t\t   std::vector<double>& w,\n\t\t   std::vector<double>& x,\n\t\t   std::vector<double>& y,\n\t\t   std::vector<double>& z) {\n\t\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    A[i][j] = A[i][j] + u1[i] * v1[j] + u2[i] * v2[j];\n\t}\n    }\n\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    x[i] = x[i] + beta * A[j][i] * y[j];\n\t}\n    }\n\n    for (int i = 0; i < n; i++) {\n\tx[i] = x[i] + z[i];\n    }\n\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < n; j++) {\n\t    w[i] = w[i] +  alpha * A[i][j] * x[j];\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "gemver"
    },
    {
        "prompt": "#include <cmath>\n#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/* Original code provided by Gael Deest */\nvoid kernel_deriche(int w, int h, double alpha,\n\t\t    std::vector<std::vector<float>>& imgIn,\n\t\t    std::vector<std::vector<float>>& imgOut,\n\t\t    std::vector<std::vector<float>>& y1,\n\t    \t    std::vector<std::vector<float>>& y2) {\n\n    float k = 1.0 - std::exp(-alpha) * (1.0 - std::exp(-alpha)) / (1.0 + 2.0 * alpha * std::exp(-alpha) - std::exp(2.0 * alpha));\n    float a1, a2, a3, a4, a5, a6, a7, a8;\n    float b1, b2, c1, c2;\n\n    a1 = a5 = k;\n    a2 = a6 = k * std::exp(-alpha) * (alpha - 1.0);\n    a3 = a7 = k * std::exp(-alpha) * (alpha + 1.0);\n    a4 = a8 = -k * std::exp(-2.0 * alpha);\n    b1 = std::pow(2.0, -alpha);\n    b2 = -std::exp(-2.0 * alpha);\n    c1 = c2 = 1;\n\n    for (int i = 0; i < w; i++) {\n        float ym1 = 0.0;\n        float ym2 = 0.0;\n        float xm1 = 0.0;\n        for (int j = 0; j < h; j++) {\n            y1[i][j] = a1*imgIn[i][j] + a2*xm1 + b1*ym1 + b2*ym2;\n            xm1 = imgIn[i][j];\n            ym2 = ym1;\n            ym1 = y1[i][j];\n        }\n    }\n\n    for (int i = 0; i < w; i++) {\n        float yp1 = 0.0;\n        float yp2 = 0.0;\n        float xp1 = 0.0;\n        float xp2 = 0.0;\n        for (int j = h - 1; j >= 0; j--) {\n            y2[i][j] = a3*xp1 + a4*xp2 + b1*yp1 + b2*yp2;\n            xp2 = xp1;\n            xp1 = imgIn[i][j];\n            yp2 = yp1;\n            yp1 = y2[i][j];\n        }\n    }\n\n    for (int i = 0; i < w; i++) {\n        for (int j = 0; j < h; j++) {\n            imgOut[i][j] = c1 * (y1[i][j] + y2[i][j]);\n        }\n    }\n\n    for (int j = 0; j < h; j++) {\n        float tm1 = 0.0;\n        float ym1 = 0.0;\n        float ym2 = 0.0;\n        for (int i = 0; i < w; i++) {\n            y1[i][j] = a5*imgOut[i][j] + a6*tm1 + b1*ym1 + b2*ym2;\n            tm1 = imgOut[i][j];\n            ym2 = ym1;\n            ym1 = y1[i][j];\n        }\n    }\n\n    for (int j = 0; j < h; j++) {\n        float tp1 = 0.0;\n        float tp2 = 0.0;\n        float yp1 = 0.0;\n        float yp2 = 0.0;\n\n        for (int i = w - 1; i >= 0; i--) {\n            y2[i][j] = a7*tp1 + a8*tp2 + b1*yp1 + b2*yp2;\n            tp2 = tp1;\n            tp1 = imgOut[i][j];\n            yp2 = yp1;\n            yp1 = y2[i][j];\n        }\n    }\n\n    for (int i = 0; i < w; i++) {\n        for (int j = 0; j < h; j++) {\n            imgOut[i][j] = c2*(y1[i][j] + y2[i][j]);\n\t}\n    }\n}\n",
        "src_code": "#include <cmath>\n#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\n/* Original code provided by Gael Deest */\nvoid kernel_deriche(int w, int h, double alpha,\n\t\t    std::vector<std::vector<float>>& imgIn,\n\t\t    std::vector<std::vector<float>>& imgOut,\n\t\t    std::vector<std::vector<float>>& y1,\n\t    \t    std::vector<std::vector<float>>& y2) {\n\n    float k = 1.0 - std::exp(-alpha) * (1.0 - std::exp(-alpha)) / (1.0 + 2.0 * alpha * std::exp(-alpha) - std::exp(2.0 * alpha));\n    float a1, a2, a3, a4, a5, a6, a7, a8;\n    float b1, b2, c1, c2;\n\n    a1 = a5 = k;\n    a2 = a6 = k * std::exp(-alpha) * (alpha - 1.0);\n    a3 = a7 = k * std::exp(-alpha) * (alpha + 1.0);\n    a4 = a8 = -k * std::exp(-2.0 * alpha);\n    b1 = std::pow(2.0, -alpha);\n    b2 = -std::exp(-2.0 * alpha);\n    c1 = c2 = 1;\n\n    for (int i = 0; i < w; i++) {\n        float ym1 = 0.0;\n        float ym2 = 0.0;\n        float xm1 = 0.0;\n        for (int j = 0; j < h; j++) {\n            y1[i][j] = a1*imgIn[i][j] + a2*xm1 + b1*ym1 + b2*ym2;\n            xm1 = imgIn[i][j];\n            ym2 = ym1;\n            ym1 = y1[i][j];\n        }\n    }\n\n    for (int i = 0; i < w; i++) {\n        float yp1 = 0.0;\n        float yp2 = 0.0;\n        float xp1 = 0.0;\n        float xp2 = 0.0;\n        for (int j = h - 1; j >= 0; j--) {\n            y2[i][j] = a3*xp1 + a4*xp2 + b1*yp1 + b2*yp2;\n            xp2 = xp1;\n            xp1 = imgIn[i][j];\n            yp2 = yp1;\n            yp1 = y2[i][j];\n        }\n    }\n\n    for (int i = 0; i < w; i++) {\n        for (int j = 0; j < h; j++) {\n            imgOut[i][j] = c1 * (y1[i][j] + y2[i][j]);\n        }\n    }\n\n    for (int j = 0; j < h; j++) {\n        float tm1 = 0.0;\n        float ym1 = 0.0;\n        float ym2 = 0.0;\n        for (int i = 0; i < w; i++) {\n            y1[i][j] = a5*imgOut[i][j] + a6*tm1 + b1*ym1 + b2*ym2;\n            tm1 = imgOut[i][j];\n            ym2 = ym1;\n            ym1 = y1[i][j];\n        }\n    }\n\n    for (int j = 0; j < h; j++) {\n        float tp1 = 0.0;\n        float tp2 = 0.0;\n        float yp1 = 0.0;\n        float yp2 = 0.0;\n\n        for (int i = w - 1; i >= 0; i--) {\n            y2[i][j] = a7*tp1 + a8*tp2 + b1*yp1 + b2*yp2;\n            tp2 = tp1;\n            tp1 = imgOut[i][j];\n            yp2 = yp1;\n            yp1 = y2[i][j];\n        }\n    }\n\n    for (int i = 0; i < w; i++) {\n        for (int j = 0; j < h; j++) {\n            imgOut[i][j] = c2*(y1[i][j] + y2[i][j]);\n\t}\n    }\n}\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "deriche"
    },
    {
        "prompt": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_lu(int n,\n\t       std::vector<std::vector<double>>& A) {\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < i; j++) {\n\t    for(int k = 0; k < j; k++) {\n\t\tA[i][j] -= A[i][k] * A[k][j];\n\t    }\n\t    A[i][j] /= A[j][j];\n\t}\n\n\tfor (int j = i; j < n; j++) {\n\t    for (int k = 0; k < i; k++) {\n\t\tA[i][j] -= A[i][k] * A[k][j];\n\t    }\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\n/* Main computational kernel. The whole function will be timed,\n   including the call and return. */\nvoid kernel_lu(int n,\n\t       std::vector<std::vector<double>>& A) {\n    for (int i = 0; i < n; i++) {\n\tfor (int j = 0; j < i; j++) {\n\t    for(int k = 0; k < j; k++) {\n\t\tA[i][j] -= A[i][k] * A[k][j];\n\t    }\n\t    A[i][j] /= A[j][j];\n\t}\n\n\tfor (int j = i; j < n; j++) {\n\t    for (int k = 0; k < i; k++) {\n\t\tA[i][j] -= A[i][k] * A[k][j];\n\t    }\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "lu"
    },
    {
        "prompt": "#include <vector>\n\nvoid kernel_floyd_warshall(int n, std::vector<std::vector<int>>& path) {\n    for (int k = 0; k < n; k++) {\n\tfor (int i = 0; i < n; i++) {\n\t    for (int j = 0; j < n; j++) {\n\t\tpath[i][j] = std::min<int>(path[i][j], path[i][k] + path[k][j]);\n\t    }\n\t}\n    }\n}\n\n",
        "src_code": "#include <vector>\n\nvoid kernel_floyd_warshall(int n, std::vector<std::vector<int>>& path) {\n    for (int k = 0; k < n; k++) {\n\tfor (int i = 0; i < n; i++) {\n\t    for (int j = 0; j < n; j++) {\n\t\tpath[i][j] = std::min<int>(path[i][j], path[i][k] + path[k][j]);\n\t    }\n\t}\n    }\n}\n\n",
        "problem_type": "polybench",
        "language": "cpp",
        "parallelism_model": "serial",
        "prompted": false,
        "name": "floyd_warshall"
    }
]